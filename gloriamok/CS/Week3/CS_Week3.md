# CS_Week3

# 3주차 CS 정리

# 프로세스 동기화

- 여러 프로세스 사이의 수행 시기를 맞추는 것
    - 실행 순서 제어
        - 프로세스를 올바른 순서대로 실행하기
    - **상호 배제**
        - 동시에 접근해서는 안되는 자원(공유가 불가능한 자원)에 하나의 프로세스만 접근하게 함
        - → **경쟁 상태**가 발생하지 않도록 두 개 이상의 프로세스가 **임계 영역**에 동시에 접근하지 못하도록 관리
            - **임계 영역 (Critical Section)**: 공유 자원 중에서 동시에 실행하면 문제가 발생하는 자원에 접근하는 코드 영역
            - **경쟁 상태 (Race Condition)**: 두 개 이상의 프로세스나 스레드가 **공유 자원에 동시에 접근하려고 할 때, 접근의 순서나 타이밍에 따라 결과가 달라질 수 있는 상태**. 이러한 상태는 데이터의 불일치나 시스템의 오작동을 초래할 수 있음
                - **Race Condition의 예시**
                    
                    은행 계좌에서 동시에 출금 작업이 이루어지는 상황:
                    
                    1. 상황 설정:
                        - 사용자 A의 은행 계좌에는 $1000이 있습니다.
                        - 사용자 A는 두 개의 다른 기기에서 동시에 $800씩 출금하려고 합니다.
                    2. Race Condition 발생:
                        - 첫 번째 기기는 사용자 A의 계좌 잔액을 확인하고 $1000이 있음을 확인합니다.
                        - 거의 동시에 두 번째 기기도 계좌 잔액을 확인하고 $1000이 있음을 확인합니다.
                        - 첫 번째 기기는 $800을 출금하고 잔액을 $200으로 업데이트합니다.
                        - 두 번째 기기도 $800을 출금하려고 시도하고, 성공적으로 출금한 후 잔액을 $200으로 업데이트합니다.
                    3. 결과:
                        - 사용자 A의 계좌에서 총 $1600이 출금되었지만, 실제로는 $1000밖에 없었습니다.
                        - ‘잔액’이라는 임계 구역의 데이터를 동시에 사용하기 때문에 생긴 문제!
                        - 이러한 상황은 Race Condition 때문에 발생하며, 적절한 동기화 메커니즘을 사용하지 않아서 발생한 문제입니다.
                            - 상호 배제를 위한 동기화가 필요함
- 여러 프로세스나 스레드가 공유 자원에 동시에 접근할 때 **발생할 수 있는 문제**를 방지
- 데이터의 일관성과 시스템의 정확성을 보장

## 상호 배제를 위한 동기화의 세가지 원칙

1. **상호 배제 (Mutual Exclusion)**
    - **한 번에 하나의 프로세스나 스레드만이 임계 영역에 진입**할 수 있어야 합니다.
    - 다른 프로세스나 스레드가 임계 영역에 진입하려고 할 때, 이미 임계 영역에 있는 프로세스나 스레드가 완료될 때까지 **대기**해야 합니다.
2. **진행 (Progress)**
    - 임계 영역 외부에서 실행 중인 프로세스나 스레드는 다른 프로세스나 스레드의 진행을 방해해서는 안 됩니다.
    - 임계 구역에 어떤 프로세스도 진입하지 않았다면 임계 구역에 진입하고자 하는 프로세스는 들어갈 수 있어야 한다.
3. **유한 대기 (Bounded Waiting)**
    - 프로세스나 스레드가 임계 영역에 진입하려고 요청한 후부터 그 요청이 허용될 때까지의 **대기 시간은 한정**되어 있어야 합니다.
    - 이는 **무한 대기 상태 (starvation)를 방지**하기 위한 것으로, 어떤 프로세스나 스레드도 무한히 대기 상태에 머무르지 않도록 보장합니다.

## 동기화 기법

### 뮤텍스 락 (**Mutex Lock)**

- 상호 배제(mutual exclusion)를 위한 도구로, 한 번에 하나의 프로세스나 스레드만이 공유 자원에 접근할 수 있도록 보장합니다. 뮤텍스는 잠금(lock)과 해제(unlock) 연산을 제공합니다.
- 사용 예시
    - 두 개의 스레드가 동일한 공유 자원에 접근하는 상황
    - `std::mutex` 객체 `mtx`는 공유 자원 `sharedResource`에 대한 동시 접근을 제어하는 데 사용
    
    ```cpp
    #include <iostream>
    #include <thread>
    #include <mutex>
    
    std::mutex mtx;  // 뮤텍스 객체 생성
    int sharedResource = 0;  // 공유 자원
    
    void incrementResource(int n) {
        for (int i = 0; i < n; ++i) {
            mtx.lock();  // 뮤텍스 락 획득
            ++sharedResource;
            std::cout << "Resource value: " << sharedResource << std::endl;
            mtx.unlock();  // 뮤텍스 락 해제
        }
    }
    
    int main() {
        std::thread t1(incrementResource, 5);  // 첫 번째 스레드 생성
        std::thread t2(incrementResource, 5);  // 두 번째 스레드 생성
    
        t1.join();  // 첫 번째 스레드가 종료될 때까지 대기
        t2.join();  // 두 번째 스레드가 종료될 때까지 대기
    
        return 0;
    }
    
    ```
    

### **세마포어 (Semaphore)**

- 세마포어는 정수 값으로, 공유 자원에 접근할 수 있는 프로세스나 스레드의 **수를 제한**하는 데 사용됩니다. 세마포어는 두 가지 주요 연산, P (wait 또는 down) 및 V (signal 또는 up)를 제공합니다.
- 멀티플 뮤텍스 ⇒ 세마포어
    - 뮤텍스는 하나의 공유 자원에 접근하는 프로세스를 가정하고 만든 동기화 도구, 세마포어는 공유 자원이 여러 개 있을 경우 여러 개의 프로세스가 각각의 공유 자원에 접근이 가능하도록 동기화 하는 도구
- **카운팅 세마포어 (Counting Semaphore)**
    - 0 이상의 정수 값을 가질 수 있는 세마포어입니다.
    - 여러 스레드나 프로세스가 공유 자원에 동시에 접근할 수 있는 최대 허용 수를 제한하는 데 사용됩니다.
- 이진 세마포어 (Binary Semaphore)
    - 뮤텍스 락과 비슷한 개념
    - 값이 0 또는 1만을 가질 수 있음
- 구현
    - **세마포어 (전역변수 S)**
        - **임계 영역에 진입할 수 있는 프로세스의 개수**(사용 가능한 공유 자원의 개수)를 나타냄
    - **P 연산 (Wait or Acquire)**
        - 임계 영역에 들어가도 좋은지, 기다려야 할지를 알려줌
        - 세마포어의 값을 감소시킵니다.
        - 세마포어의 값이 0보다 크면, 연산은 성공적으로 수행되며 스레드나 프로세스는 계속 진행됩니다.
        - 세마포어의 값이 0이면, 스레드나 프로세스는 대기 상태에 들어갑니다.
    - **V 연산 (Signal or Release)**
        - 임계 영역 앞에서 기다리는 프로세스에 신호를 줌
        - 세마포어의 값을 증가시킵니다.
        - 대기 중인 스레드나 프로세스가 있으면, 그 중 하나를 깨워서 실행을 계속하게 합니다.
- 사용 예시
    - C++에서는 `<semaphore>` 헤더로 세마포어를 지원, 한 번에 특정 수의 스레드나 프로세스만이 임계 영역에 접근할 수 있게 제한
    - 10개의 스레드가 생성되지만, 세마포어의 제한으로 인해 한 번에 3개의 스레드만이 `accessResource` 함수에 접근할 수 있음
        
        ```cpp
        #include <iostream>
        #include <thread>
        #include <vector>
        #include <semaphore>
        
        std::counting_semaphore<3> sem(3);  // 동시에 3개의 스레드만 접근 가능
        
        void accessResource(int id) {
            sem.acquire();  // 세마포어 획득
            std::cout << "Thread " << id << " is accessing the resource." << std::endl;
            std::this_thread::sleep_for(std::chrono::seconds(2));  // 임의의 작업을 대신하여 2초 대기
            std::cout << "Thread " << id << " has finished accessing the resource." << std::endl;
            sem.release();  // 세마포어 해제
        }
        
        int main() {
            std::vector<std::thread> threads;
        
            for (int i = 0; i < 10; ++i) {
                threads.push_back(std::thread(accessResource, i));
            }
        
            for (auto& t : threads) {
                t.join();
            }
        
            return 0;
        }
        
        ```
        

### **모니터 (Monitor)**

- 세마포어에서 매번 임계 구역 앞뒤로 일일이 wait과 signal 함수를 명시하는 것은 번거로운 일이기 때문에 모니터가 생김
- 모니터는 공유 자원과 공유 자원에 접근하기 위한 인터페이스를 묶어서 관리하고 프로세스는 반드시 인터페이스를 통해서만 공유 자원에 접근하도록 함
- 사용 예시
    - Java에서는 `synchronized` 키워드를 사용하여 모니터 개념을 지원
    - `SharedResourceMonitor` 클래스는 `count`라는 공유 자원을 가지며, `increment()`, `decrement()`, `getCount()` 메서드는 `synchronized` 키워드로 동기화되어 있습니다. 이로 인해 한 번에 하나의 스레드만이 이러한 메서드 중 하나를 실행할 수 있습니다.
    
    ```java
    public class SharedResourceMonitor {
        private int count = 0;
    
        // synchronized 메서드: 한 번에 하나의 스레드만이 이 메서드를 실행할 수 있습니다.
        public synchronized void increment() {
            count++;
            System.out.println("Incremented: " + count);
        }
    
        // synchronized 메서드
        public synchronized void decrement() {
            count--;
            System.out.println("Decremented: " + count);
        }
    
        // synchronized 메서드
        public synchronized int getCount() {
            return count;
        }
    }
    
    public class MonitorExample {
        public static void main(String[] args) {
            SharedResourceMonitor monitor = new SharedResourceMonitor();
    
            // 스레드 생성 및 시작
            Thread t1 = new Thread(() -> {
                for (int i = 0; i < 5; i++) {
                    monitor.increment();
                }
            });
    
            Thread t2 = new Thread(() -> {
                for (int i = 0; i < 5; i++) {
                    monitor.decrement();
                }
            });
    
            t1.start();
            t2.start();
    
            try {
                t1.join();
                t2.join();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
    
            System.out.println("Final Count: " + monitor.getCount());
        }
    }
    
    ```
    

## 동기화에서 고려할 사항

- **기아** **(Starvation)**: 일부 프로세스나 스레드가 자원에 접근하는 것을 무한히 대기하는 상황. 동기화 메커니즘은 모든 프로세스나 스레드에 공평한 접근 기회를 제공해야 합니다.
- **교착 상태** **(Deadlock)**: 두 개 이상의 프로세스나 스레드가 서로의 자원을 기다리며 **무한히 대기**하는 상황. 동기화 메커니즘은 데드락 발생 가능성을 최소화하거나 해결해야 합니다.

# **교착 상태** **(Deadlock)**

- 두 개 이상의 프로세스나 스레드가 서로의 자원을 기다리며 **무한히 대기**하는 상황
- **식사하는 철학자 문제**
    - 5명의 철학자가 **원탁** 주위에 앉아 있습니다.
    - 각 철학자의 사이에는 포크가 하나씩 놓여 있어 총 5개의 포크가 있습니다.
    - 철학자는 생각하거나 식사하는 두 가지 활동 중 하나를 합니다.
        - **식사를 안하면 생각을 함**
    - 식사를 하려면 철학자는 자신의 왼쪽과 오른쪽에 있는 **두 개의 포크를 모두 사용**해야 합니다.
    - 포크는 **한 번에 한 철학자만 사용**할 수 있습니다.
    - **만약 모든 철학자가 동시에 왼쪽 포크를 집으면, 오른쪽 포크는 사용할 수 없게 되므로 어떤 철학자도 식사를 할 수 없고 영원히 생각만 하는 상황(교착 상태)**이 발생합니다.
    - 철학자 = 프로세스 혹은 스레드, 포크 = 임계 구역, 생각하는 행위 = 자원을 기다리는 것

## 교착 상태 발생 조건

- **상호 배제 (Mutual Exclusion)**
    - 자원은 한 번에 한 프로세스 또는 스레드만이 사용할 수 있습니다. 다른 프로세스나 스레드가 그 자원을 사용하려면, 현재 그 자원을 사용하고 있는 프로세스나 스레드가 자원을 해제할 때까지 기다려야 합니다.
- **점유와 대기 (Hold and Wait)**
    - 프로세스나 스레드는 이미 어떤 자원을 점유한 상태에서 다른 자원을 기다리고 있어야 합니다. 즉, 하나 이상의 자원을 점유하면서 다른 프로세스나 스레드가 사용하고 있는 자원을 대기하는 상태입니다.
- **비선점 (No Preemption)**
    - 자원을 한번 점유한 프로세스나 스레드는 그 자원을 스스로만 해제할 수 있습니다. 다른 프로세스나 스레드가 그 자원을 강제로 빼앗을 수 없습니다.
- **순환 대기 (Circular Wait)**
    - 두 개 이상의 프로세스나 스레드가 자원을 대기하는 사이클이 형성되어야 합니다. 예를 들어, 프로세스 A는 자원 X를 점유하면서 자원 Y를 대기하고, 프로세스 B는 자원 Y를 점유하면서 자원 X를 대기하는 상황입니다.
- 이 네 가지 조건이 동시에 만족될 때 교착 상태가 발생할 수 있음 (위 조건 중 하나라도 만족하지 않는다면 교착 상태가 발생하지 않음)
- 교착 상태를 예방하거나 해결하기 위해서는 이 조건들 중 하나 이상을 없애야 함

## 교착 상태 해결 방법

- 예방, 회피, 탐지 및 회복, 무시
- **교착 상태 예방 (Deadlock Prevention)**
    - 교착 상태 발생 조건 중 하나 이상을 깨트려 교착 상태가 발생하지 않도록 하는 방법
    - **상호 배제**
        - 모든 자원을 공유 가능하게 만듦
        - 이 조건은 공유할 수 없는 자원에 대해 피할 수 없습니다. 따라서 대부분의 경우 이 조건을 깨트리는 것은 실용적/현실적이지 않습니다.
    - **점유와 대기**
        - 프로세스가 자원을 요청할 때 필요한 모든 자원을 한 번에 요청하도록 합니다.
        - 자원의 활용률이 낮아짐
        - 자원을 많이 사용하는 프로세스는 자원을 사용할 타이밍을 확보하기가 어려워짐 → 기아 현상을 야기할 우려 있음
    - **비선점**
        - 자원을 점유하고 있는 프로세스가 다른 자원을 요청하고 그 자원을 얻지 못할 경우, 이미 점유하고 있는 자원을 해제하고 대기합니다. (선점)
        - 모든 자원에 대해서 가능하지 않음 (한 프로세스가 프린터를 이용하는 도중에 다른 프로세스가 프린터 자원을 빼앗아 사용할 수 없음)
    - **순환 대기**
        - 자원에 고유한 번호를 할당하고, 프로세스는 번호 순서대로 자원을 요청하도록 합니다.
        - 모든 컴퓨터 시스템 내에 존재하는 수많은 자원에 번호를 붙이는 것은 간단하지 않음
        - 각 자원에 어떤 번호를 붙이는지에 따라 특정 자원의 활용률이 떨어질 수 있음
- **교착 상태 회피 (Deadlock Avoidance)**
    - 시스템의 상태를 주기적으로 검사하여 교착 상태가 발생할 가능성이 있는 경우 해당 자원의 할당을 회피하는 방법
- **교착 상태 탐지 및 회복 (Deadlock Detection and Recovery)**
    - 시스템에서 주기적으로 교착 상태를 탐지하고, 발견된 교착 상태를 해결하는 방법
    - **탐지**: 자원 할당 그래프를 사용하여 교착 상태를 탐지합니다.
    - **회복**: 교착 상태에 있는 프로세스를 **종료**하거나, 교착 상태에 있는 프로세스의 자원을 **선점**하여 교착 상태를 해결합니다.
- **교착 상태 무시 (Deadlock Ignorance)**
    - 실제 시스템에서 교착 상태가 발생하는 빈도가 낮다고 가정하고, 교착 상태에 대한 대응을 하지 않는 방법
    - 교착 상태의 발생 빈도와 그로 인한 비용을 고려하여 선택됨

# CPU 스케줄링

- 운영체제가 여러 프로세스나 스레드 중에서 CPU를 어떤 순서로 할당할 것인지 결정
    - 공정하고 합리적으로 배분!
    - CPU 스케줄러(Short-term Scheduler)는 Ready Queue에 있는 프로세스 중에서 다음에 CPU를 할당받을 프로세스를 선택
- CPU 사용률을 최대화하고, 시스템의 처리량(throughput)을 향상시키며, 응답 시간을 최소화하는 것이 목표

## CPU 스케줄링 기준

1. **CPU 사용률 (CPU Utilization)**
    - CPU가 활성 상태로 있어야 하는 시간의 비율입니다.
    - 목표는 CPU 사용률을 최대화하는 것입니다.
2. **처리량 (Throughput)**
    - 단위 시간당 시스템이 완료할 수 있는 프로세스의 수입니다.
    - 높은 처리량은 시스템의 효율성을 나타냅니다.
3. **턴어라운드 시간 (Turnaround Time)**
    - 프로세스가 시스템에 도착한 시간부터 완료될 때까지 걸린 시간입니다.
    - 턴어라운드 시간을 최소화하는 것이 목표입니다.
4. **대기 시간 (Waiting Time)**
    - 프로세스가 준비 큐에서 CPU 할당을 기다리는 데 걸린 총 시간입니다.
    - 대기 시간을 최소화하는 것이 바람직합니다.
5. **응답 시간 (Response Time)**
    - 사용자 요청이나 프로세스의 시작부터 첫 번째 응답이 출력될 때까지의 시간입니다.
    - 대화식 시스템에서는 응답 시간을 최소화하는 것이 중요합니다.
6. **공평성 (Fairness)**
    - 모든 프로세스에 공평하게 CPU 시간을 할당하는 것입니다.
    - 특정 프로세스가 다른 프로세스보다 더 많은 CPU 시간을 점유하는 것을 방지합니다.
7. **우선순위 (Priority)**
    - 특정 프로세스에 높은 우선순위를 부여하여 중요한 작업을 먼저 처리하도록 합니다.
8. **자원 사용 최적화 (Resource Utilization)**
    - CPU뿐만 아니라 다른 시스템 자원(메모리, I/O 장치 등)의 사용률도 최적화하는 것입니다.

## CPU 스케줄링 알고리즘

### 비선점형 스케줄링

1. **First-Come, First-Served (FCFS)**
    - 가장 먼저 도착한 프로세스부터 CPU를 할당합니다. (FIFO처럼)
    - 공평하지만, 평균 대기 시간이 길 수 있습니다.
2. **Shortest Job Next (SJN) 또는 Shortest Job First (SJF)**
    - 가장 짧은 실행 시간을 가진 프로세스에 먼저 CPU를 할당합니다.
    - 평균 대기 시간을 최소화하는 것이 목표입니다.
    - 가장 짧은 실행 시간을 가진 프로세스가 무엇인지 예측하기 어려움

### 선점형 스케줄링

1. **Priority Scheduling**
    - 각 프로세스에 우선순위를 할당하고, 가장 높은 우선순위를 가진 프로세스에 먼저 CPU를 할당합니다.
2. **Round Robin (RR)**
    - 각 프로세스에 동일한 시간 할당량(time quantum)을 부여하고, 이 시간 동안 CPU를 사용하게 합니다.
    - 모든 프로세스가 공평하게 CPU를 사용할 수 있습니다.

### 비선점형과 선점형 스케줄링 알고리즘의 차이점

1. **CPU 할당의 방식**:
    - **비선점형 스케줄링**: 한 번 CPU가 프로세스에 할당되면, 해당 프로세스가 종료되거나 I/O 요청과 같은 이벤트가 발생하여 실행을 중단할 때까지 CPU를 계속 사용합니다. 다른 프로세스는 현재 실행 중인 프로세스가 종료될 때까지 기다려야 합니다.
    - **선점형 스케줄링**: 현재 실행 중인 프로세스가 할당된 시간 할당량을 모두 사용하거나, 더 높은 우선순위의 프로세스가 준비 상태가 되면 CPU를 강제로 회수하여 다른 프로세스에 할당할 수 있습니다.
2. **응답 시간**:
    - **비선점형 스케줄링**: 프로세스의 실행 시간이 길 경우, 다른 프로세스의 응답 시간이 길어질 수 있습니다.
    - **선점형 스케줄링**: 높은 우선순위의 프로세스나 짧은 작업에 빠른 응답 시간을 제공할 수 있습니다.
3. **복잡성**:
    - **비선점형 스케줄링**: 구현이 상대적으로 간단합니다.
    - **선점형 스케줄링**: 컨텍스트 스위칭, 우선순위 관리 등의 추가적인 메커니즘이 필요하므로 구현이 복잡할 수 있습니다.
4. **컨텍스트 스위칭**:
    - **비선점형 스케줄링**: 프로세스가 자발적으로 CPU를 반납할 때만 컨텍스트 스위칭이 발생합니다.
    - **선점형 스케줄링**: 주기적인 인터럽트나 우선순위 변경에 따라 빈번한 컨텍스트 스위칭이 발생할 수 있습니다.


# 내용출처

- [혼자 공부하는 컴퓨터 구조+운영체제 - 예스24 (yes24.com)](https://www.yes24.com/Product/Goods/111378840)
- [2023-CS-Study/OS/README.md at main · devSquad-study/2023-CS-Study (github.com)](https://github.com/devSquad-study/2023-CS-Study/blob/main/OS/README.md)
- [ChatGPT (openai.com)](https://chat.openai.com/)